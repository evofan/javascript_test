// https://developer.mozilla.org/ja/docs/Web/JavaScript/EventLoop
// 並列モデルとイベントループ
// JavaScriptは、"event loop"に基づく同時実行モデルを持ちます。このモデルはC言語やJavaのような他の言語のモデルとかなり異なっています。

// ■ ランタイムの概要
// 後続のセクションでは、理論モデルを説明します。現代のJavaScriptエンジンは、記載されたセマンティクスに従って実装され、また高度に最適化されています。

// □ 視覚表示
// （画像参照）

// □ スタック（Stack）
// 関数呼び出しは、フレームのスタックを形成します。
function foo(b) {
  let a = 0;
  return a + b + 11;
}
function bar(x) {
  let y = 3;
  return foo(x * y);
}
console.log(bar(7)); // 32

// bar()を呼び出すと、barの引数とローカル変数（y）を含んだ最初のフレームが形成されます。
// bar()がfoo()を呼び出すと、foo()の引数とローカル変数（a）を含んだ2番目のフレームが形成され、最初のフレームの上にプッシュ（末尾に追加）されます。
// foo()側から返ると、先頭のフレーム要素(bar)はスタックからポップ（末尾を削除）されます（barのコールフレームのみ残る）。
// bar()から返る時、スタックは空になります。

// □ ヒープ（Heap）
// オブジェクトはヒープに割り当てられています。
// （★ヒープとは、メモリの大規模で大部分は構造化されていない領域を意味する名前）

// □ キュー（Queue）
// JavaScriptのランタイムは、★「メッセージキュー＝キュー」を含んでいます。
// （メッセージキューとは、処理されるメッセージのリスト）
// 各メッセージに関数を関連付けれられています。
// スタックが空の時、メッセージがキューから取り出され、処理されます。
// その処理は、関連する関数の呼び出し（と最初のスタックフレームの作成）で構成されています。
// スタックが再度空になると、メッセージ処理は終了します。

// ■ イベントループ
// event loopという名前は、それが一般的にどのように実装されたかに従って付けられました。
// これは、通常次のものに似ています。
/*
while (queue.waitForMessage()) {
  queue.processNextMessage();
}
*/
// queue.message()はもしその時点でメッセージキューが存在しないのであれば、同期的にメッセージキューが到着するのを待ちます。

// □ "Runt-tocompletion"
// その他のメッセージキューが処理される前に、各メッセージキューは完全に処理されています。
// 関数が実行される度に、それが横取りする事は出来ず、他のコードが実行される前に、完全に実行されます（及び関数が操作するデータを変更出来る）。
// ↑の事実は、プログラムについて推論する時に幾つかの素晴らしい特性を提供しています。
// 例えば、これはC言語とは異なります。
// （Cはスレッドで別の関数を停止したり出来るから？）→JavaScriptはシングルスレッド

// このモデルの欠点は、メッセージキューが完了するまでに時間が掛かりすぎる場合は、Webアプリケーションはクリックやスクロールのような
// ユーザーインタラクションの処理が出来ない事です。→フリーズした状態になる

// □ メッセージの追加
// Webブラウザでは、メッセージキューは、イベントが発生し、それに接続されているイベントリスナーがある任意のじかんに追加されます。
// イベントリスナーが無い場合、イベントは失われます。※Promiseのようなのは？
// だから他のイベントと同様に、クリックイベントハンドラを持つ要素をクリックすると、メッセージキューが追加されます。

// setTimeOut()を呼び出すと、2番目の引数が渡された時間が経過した後、メッセージキューがキューに追加されます。
// キューに他のメッセージキューが無い場合に、メッセージはすぐに処理されます。
// しかしながら、メッセージキューがある場合、setTimeOutメッセージは、他のメッセージキューが処理されるまで待機する必要があります。
// そのため、第二引数は保証時間でなく、最小時間を示しています。

// □ 一緒に通信する幾つかのランタイム
// ウェブワーカーや、クロスオリジンのiFrameは、独自のスタック・ヒープ・及びメッセージキューがあります。
// 2つの異なるランタイムのみpostMEssage()メソッドによって、送信メッセージキューを介して通信が出来ます。
// 他のランタイムがmessageイベントをリッスンする場合、このメソッドは他のランタイムにメッセージキューを追加します。

// ■ ブロッキング不可
// イベントループモデルの非常に興味深い特性は、他の多くの言語と異なりJavaScriptは決してブロックをしないという事です。
// Input/Outputの取り扱いは、通常イベントのコールバックを介して行われます。
// その為、アプリケーションは、IndexedDBのクエリた、XHRリクエストが返るのを待っている間も、ユーザー入力の様な他の事をする事が出来ます。

// alertか同期XHRの様なレガシーな例外が存在しますが、それら（同期処理？）を避ける事はよい慣習とされています。
