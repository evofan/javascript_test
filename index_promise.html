<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <title>JavaScript Test</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />

    <link rel="stylesheet" type="text/css" href="css/main.css">
    <script src="https://cdn.rawgit.com/google/code-prettify/master/loader/run_prettify.js"></script>


  </head>

  <body>
    <div id="conatiner">
      <h1>JavaScript Test Memo</h1>
      <h2>Promise</h2>
      
      <p>テスト内容はChromeのコンソールに表示＋参考ページを元にサンプル作成</p>

      <!--s/-->
      <script>
       // ■ PromiseとEventListenerの違い
       // ・Promiseは1回しか成功/失敗出来ない（イベントリスナーは「ボタン押した」等、何回も取得出来る）
       // ・Promiseが成功/失敗し、後から成功/失敗のコールバックを追加すると、その前にイベントが実行されていても（終わっていても？）、
       //   正しいコールバックが呼び出される

       // ■ Promiseの用語
       // ・履行済み ... fulfilled、Promiseに関する操作が成功した、フールフィルド：満たされた
       // ・棄却済み ... rejected、Promiseに関連する操作が失敗した、リジェクテッド：拒否された
       // ・保留中 ... pending、まだ履行も棄却もされていない、ペンディング：保留中
       // ・完了 ... 履行又は棄却された

        let a = 2; // ↓のテスト確認用

       // ■ Promiseの作成方法
       let promise_1 = new Promise((resolve, reject) => {
         // 何かをする、おそらく非同期、…
         if (a === 2/*全てがうまくいった*/) {
           resolve("ものが動いた！");
         } else {
           reject(Error("壊れた"));
         }
       });
       //（１）Promiseコンストラクターはコールバックを1つの引数として取り、コールバックはresolveとrejectの2つのパラメーターを取る
       //（２）コールバック内で何らかの処理（非同期処理等）を行い、全てが成功すると呼び出しが解決（resolve）され、そうでない場合は呼び出しは棄却（reject）される
       // ※rejectはエラーをスローする事が慣例だが、必須ではない。

       // ■ Promiseの使用方法
       promise_1.then((result) => {
         console.log(result); // "ものが動いた！"
       }, (err) => {
         console.log(err); // Error: 壊れた
       });
       //（１）then()は2つの引数、成功時のコールバックと失敗時のコールバックを取る。両方とも省略可能。片方だけの記述も可。

       // ■ 複雑な非同期コードを簡単にする事例
       
       // promiseを適用する処理
       // 1.読み込み中である事を示すスピナーを開始する
       // 2.各章毎のタイトルとURLを示す記事のJSONを取得する
       // 3.ページにタイトルを追加する
       // 4.各章を取得する
       // 5.ページに記事を追加する
       // 6.スピナーを停止する

       // ※途中で処理が失敗した時は、それをユーザーに通知する（スピナーは停止させる）

       // ■ XMLHttpRequestのPromise化
       // ※古いAPIは、後方互換性を残したまま更新出来るなら、Promiseを使用して更新する（考え方）
       function get(url) {
         
         // 新しいPromiseを返す
         return new Promise((resolve, reject) => {

           // 普通にXHRを使う
           let req = new XMLHttpRequest();
           req.open("GET", url);

           req.onload = function() {
             
             // これは404等でも呼び出されるので、ステータスをチェックする必要がある
             if (req.status === 200) {
               // レスポンステキストでpromiseを解決する
               resolve(req.response);
             }
             else {
               // それ以外の場合は、ステータステキストで拒否する
               // これは、意味のあるエラーになることを願っている
               reject(Error(req.statusText));
             }
           };

           // ネットワークエラーをハンドルする
           req.onerror = function() {
             reject(Error("Network Error"));
           };

           // リクエストを送信
           req.send();

         });

       }
      
       // 実際に↑を呼び出す
       /*
       get("json/story.json").then((response) => { // 第一引数
         console.log("Success!", response) // Success!
         // {
         //   "heading": "<h1>A story about something</h1>",
         //   "chapterUrls": ["chapter-1.json", "chapter-2.json", "chapter-3.json", "chapter-4.json",  "chapter-5.json"]
         // }
       }, (error) => { // 第二引数
         console.error("Filed!", error);
       });
       */

       // ■  then()の連鎖
       // 複数のthen()を連鎖させて、値を変換したり、追加の非同期処理を順番に実行出来る

       // 連鎖の例
       // 値の変換、単純に新しい値を返す事で、値を変換する事が出来る
       /*
       let promise_2 = new Promise((resolve, reject) => {
         resolve(1);
       });

       promise_2.then((val) => {
         console.log(val); // 1
         return val + 2; // ★連鎖させる場合はreturnで値（結果）を返す（＝次のthen()の引数として渡す）
       })
       .then((val) => {
         console.log(val); // 3
       });
       */

       // 実用的な例としてstory.jsonを取得するサンプルを修正、※JSONのresponseTypeを使用する
       // https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/responseType
       /*
         get("json/story.json").then((response) => { // 第一引数
          return JSON.parse(response);
       }).then((response) => {
          console.log("Yey! JSON! ", response); // Yey! JSON!  Object: {heading: "<h1>A story about something</h1>", chapterUrls: Array(5)}
       }), 
       (error) => { // 第二引数
         console.error("Filed!", error);
       };
       */

       // ↑さらにJSON.parseを短くショートカット（JSON.parse()は単一の引数を取り、変換された値を返す為）
       /*
       get("json/story.json")
       .then(JSON.parse)
       .then((response) => {
          console.log("Yey! JSON! ", response); // Yey! JSON!  Object: {heading: "<h1>A story about something</h1>", chapterUrls: Array(5)}
       }), 
       (error) => { // 第二引数
         console.error("Filed!", error);
       };
       */

       // JSONの取得自体を短く書ける
       function getJSON(url) {
         return get(url).then(JSON.parse);
       }
       /*
       let aa = getJSON("json/story.json");
       console.log("aa: ", aa); // aa:  Promise {<pending>}
       */

      // ■ 非同期処理のキューへの格納
      // then()を連鎖させて、非同期処理を連続して実行する事も出来る

      // then()コールバックから何らかの値が返れされると、その値を指定して次のthen()が呼び出される
      // 但し、promiseに似たものが返された時は、次のthen()はその時点で待機し、そのPromiseが完了（成功/失敗）した場合のみ呼び出される
      // ↓例
      /*
      getJSON("json/story.json").then((story) => {
        return getJSON("json/" + story.chapterUrls[0]);
      }).then((chapter1) => {
        console.log("Got chapter 1!", chapter1);
      });
      */

      // ↑story.json内の一連のjson（chapter-1.json～chpter-5.json）の1つ目をリクエストしている。
      // XHR finished loading: GET "http://localhost:8000/json/story.json".
      // Got chapter 1! {chapter: 1, html: "<p>Chapter 1 text: Cras sollicitudin orci ac velit…bibendum, cursus lectus sed, ultricies risus.</p>"}
      // XHR finished loading: GET "http://localhost:8000/json/chapter-1.json".

      // ↓章を取得するためのメソッドのショートカット
      let storyPromise;
      function getChapter(i) {
        storyPromise = storyPromise || getJSON("json/story.json"); // storyPromiseがあればそれを使用、無ければstory.jsonを取得
        return storyPromise.then((story) => {
          return getJSON("json/" + story.chapterUrls[i]);
        });
      };

      // それを使用するのは簡単です：
      getChapter(0).then((chapter) => {
        console.log(chapter); // {chapter: 1, html: "<p>Chapter 1 text: Cras sollicitudin orci ac velit…bibendum, cursus lectus sed, ultricies risus.</p>"}
        return getChapter(1);
      }).then((chapter) => {
        console.log(chapter); // {chapter: 2, html: "<p>Chapter 2 text: Curabitur laoreet cursus lectus… fringilla, sodales risus in, euismod libero.</p>"}
      })

      // ■ エラー処理
      // これまで見てきた通り、then()は成功と失敗（履行と棄却）の2つの引数を取る
       get("json/story.json").then((response) => { // 第一引数
         console.log("Success!", response)
       }, (error) => { // 第二引数
         console.error("Filed!", error);
       });

       // これ以外の方法で、catch()を使用する事も出来る
       get("json/story.json").then((response) => {
         console.log("Success!", response)
       }).catch((error) => {
         console.error("Filed!", error);
       });

       // 但し、↑のcatch()を使ったコードは、↑↑と同じではなく、↓に等しい
       get("json/story.json").then((response) => {
         console.log("Success!", response)
       }).then(undefined, (error) => {
         console.error("Filed!", error);
       });

       // 違いとして、処理はPromiseで棄却されると、棄却のコールバックを持つ次のthen()又は同等であるcatch()までスキップされる。
       // .then(func1, func2)と指定すると、fun1又はfunc2のどちらかが呼び出される
       // .then(func1).catch(func2)と書くと、func1が棄却された場合には両方（func2も）呼び出される
       // ※これは、これらが連鎖はしているが個別のstepである為

      // try～catch構文に似て、try内で発生したエラーは即catch()ブロックに入る
      /*
      asyncThing1().then(() => {
        return asyncThing2();
      }).then(() => {
        return asyncThing3();
      }).catch((err) => {
        return asyncRecovery1();
      }).then(() => {
        return asyncThing4();
      }, (err) => {
        return asyncRecovery2()
      }).catch((err) => {
        console.log("心配しないで");
      }).then(() => {
        console.log("全部終わった！");
      });
      */

      // ■ JavaScriptの例外とPromise

      // 棄却は、Promiseが明示的に棄却された場合に発生するが、コンストラクタのコールバックでエラーがスルーされた場合にも暗黙的に発生する
      /*
      let jsonPromise = new Promise((resolve, reject) => {
        // JSON.parseをフィードするとエラーがスローされます
        // 無効なJSONなので、これは暗黙的に拒否します：
        resolve(JSON.parse("This isn't JSON"))
      });
      jsonPromise.then((data) => {
        // これは決して起こりません：
        console.log("It worked!", data)
      }).catch((err) => {
        // 代わりに、これが起こります：
        console.log("It failed!", err); // It failed! SyntaxError: Unexpected token T in JSON at position 0
      });
      */

      // これはPromiseコンストラクタコールバック内で全てのPromise関連処理を行うと、エラーが自動的に取得され、棄却される為、便利である事を意味する
      // then()コールバックでスローされるエラーについても同じ事が言える

      get("/").then(JSON.parse).then(() => {
          // これは決して起こりません。「/」はJSONではなくHTMLページです
          // なので、JSON.parse()がエラーをスローします
          console.log("It worked!", data);
      }).catch((err) => {
          // 代わりに、これが起こります：
          console.log("It failed!", err); // It failed! SyntaxError: Unexpected token < in JSON at position 0 at parse (<anonymous>)
      });

      // ■ エラー処理の実例
      // 記事と賞のサンプルの例では、catch()を使用してユーザーにエラーを表示出来る
      getJSON("json/story.json").then((story) => {
        return getJSON("json", story.chapterUrls[0]);
      }).then((chapter1) => {
        addHtmlPage(chapter1.html);
      }).catch(() =>  {
        addTextToPage("Failed to show chapter"); // Uncaught (in promise) ReferenceError: addTextToPage is not defined
      }).then(() => {
        document.querySelector(".spinner").style.display = "none";
      });

      // story.chapterUrls[0]の取得に失敗した場合（http500やユーザーがオフラインだった場合等）、それ以降の全て（の成功のコールバックが）がスキップされる
      // 結果として、"Failed to show chapter"がページに表示される
      // try～catchの後と同様に、エラーが取得され、それ以降のコードが実行されるため、スピナーは常に非表示になる（これは期待される挙動なのでOK）
      
      // ↑コードのtry～cacth仕様版
      try {

      }
      catch (e) {
        addTextToPage("Failed to show chapter")
      }
      document.querySelector(".spinner").style.display = "none";

      </script>

    <div class="network-fake">
      <label><input type="checkbox"> Fake network delay</label>
    </div>
    <div class="story"></div>
    <svg class="spinner" viewBox="0 0 100 100" width="20" height="20">
      <circle cx="50" cy="50" r="42" transform="rotate(-90,50,50)" />
    </svg>

      <p class="title">JavaScriptのPromise: 概要</p>
      <pre>
      <code class="prettyprint">
      </code>
      </pre>
      <!--/s-->

      <p class="title">参考サイト：</p>

      <p><a href="https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Global_Objects/Promise" target="_blank">Promise - JavaScript - MDN - Mozilla</a></p>
      
      <p><a href="https://developer.mozilla.org/ja/docs/Web/JavaScript/Guide/Using_promises" target="_blank">Promiseを使う - JavaScript | MDN</a></p>
      
      <p><a href="https://developers.google.com/web/fundamentals/primers/promises?hl=ja" target="_blank">JavaScript の Promise: 概要</a></p>

      <!--<p><a href="" target="_blank"></a></p>-->
    
    </div>

    <script src="src/utils.js"></script>
    <!--<script src="src/promise_use.js"></script>-->
    <!--<script src="src/promise.js"></script>-->
  </body>
</html>
